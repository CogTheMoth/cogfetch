#!/bin/bash

# For copyright & license, read the file "LICENSE"

## Config ##
[ -r /etc/cogfetch ] && source /etc/cogfetch # System config
[ -r ~/.cogfetch ] && source ~/.cogfetch; # User config
[ "$DEFAULT_GATHERS" ] || DEFAULT_GATHERS='host uptime os kernel pkgs mounts mem bat colors'
[ "$PKG_MANAGERS" ] || PKG_MANAGERS=()
[ "$ART" ] || ART=()
[ "$DELIMITER_CHAR" ] || DELIMITER_CHAR=':'
[ "$SPACE_FROM_START" ] || SPACE_FROM_START=0
[ "$SPACE_FROM_ART" ] || SPACE_FROM_ART=1
[ "$SPACE_FROM_KEY" ] || SPACE_FROM_KEY=1
[ "$SPACE_FROM_DELIMITER" ] || SPACE_FROM_DELIMITER=1
[ "$COLOR_KEY" ] || COLOR_KEY='1;32'
[ "$COLOR_DELIMITER" ] || COLOR_DELIMITER='1;35'
[ "$COLOR_VALUE" ] || COLOR_VALUE='0'

## Utils ##
util_makespaces()
{
	spacing=''
	for (( i=0; i < $1; i++ )) do 
		spacing+=' '
	done
	echo "$spacing"
}
util_rm_ansicolor()
{
	echo -e "$1" | sed 's/\x1b\[[0-9;]*m//g'
}
# Typing $(awk <<< string) is too tedious
util_awk()
{
	awk "$2" <<< "$1"
}

## Gathers ##
get_host()
{
	log 'Host' "$(hostname).$(whoami) ($(cat /sys/class/dmi/id/product_name))"
}
get_uptime()
{
	log 'Uptime' "$(uptime -p)"
}
get_os()
{
	log 'OS' "$(lsb_release -sd) ($(uname -o))"
}
get_kernel()
{
	log 'Kernel' "$(uname -sr)"
}
get_pkgs()
{
	for (( i=0; i < (${#PKG_MANAGERS[@]} / 3); i++ )); do 
		(( j=i*3 ))

		# Getting some stuff from the array
		label=${PKG_MANAGERS[j]}
		cmd=${PKG_MANAGERS[j+1]}
		opts=${PKG_MANAGERS[j+2]}

		[ $(which $cmd) ] && log "Pkgs ($label)" "$($cmd $opts | wc -l)"
	done
}
get_colors()
{
	palette=''
	for (( i=0; i <= 7; i++ )); do 
		palette+="\e[4${i}m   "
	done
	log 'Colors' "$palette\e[m"
}
# Not sure how good are the implementations for these
get_mounts()
{
	# Getting information about mounts with 'df'
	info=$(df -hT -xtmpfs -xdevtmpfs -xefivarfs | awk 'NR>=2')

	# Looping through the $info
	for (( i=1; i <= $(wc -l <<< "$info"); i++ )); do
		line=$(util_awk "$info" "NR==$i")

		dev=$(util_awk "$line" '{print $1}')
		size=$(util_awk "$line" '{print $3}')
		used=$(util_awk "$line" '{print $4}')
		perc=$(util_awk "$line" '{print $6}')
		type=$(util_awk "$line" '{print $2}')
		path=$(util_awk "$line" '{print $7}')

		log "Mount ($dev)" "$used / $size ($perc) $type; mounted on '$path'"
	done
}
get_mem()
{
	info=$(free --mebi | awk 'NR>=2')
	# RAM
	mem=$(util_awk "$info" 'NR==1')
	used=$(util_awk "$mem" '{print $3}')
	total=$(util_awk "$mem" '{print $2}')
	log 'Memory' "$used / $total (MiB)"

	# Swap
	swp=$(util_awk "$info" 'NR==2')
	used=$(util_awk "$swp" '{print $3}')
	total=$(util_awk "$swp" '{print $2}')
	if (( total > 0 )); then log 'Swap' "$used / $total (MiB)"; fi
}
get_bat()
{ 
	for bat in $(find /sys/class/power_supply/BAT*); do
		# Getting battery's capacity and its status (Discharging or Charging)
		capacity=$(cat ${bat}/capacity)
		status=$(cat ${bat}/status)

		log "Battery ($(basename $bat))" "${capacity}% ($status)"
	done
}

## Main ##
# Preparing $to_gather while checking options with the most awful method possible
to_gather=$DEFAULT_GATHERS; new_gathers=''; append=0
for v in ${@:1}; do
	if [ $v == '+' ]; then
		append=1
	else 
		new_gathers+=" $v"
	fi
done
(( $append )) && to_gather+=" $new_gathers" || if (( ${#new_gathers} > 0 )); then to_gather=$new_gathers; fi

# Measuring the art
artp_n=${#ART[@]}; art_width=0
for (( i=0; i < artp_n; i++ )); do
	clr=$(util_rm_ansicolor "${ART[i]}")
	(( ${#clr} > art_width )) && art_width=${#clr}
done

# Something that will help us to line up all
logs=(); key_longestwidth=0
log()
{
	# Trying to find longest width
	(( ${#1} > key_longestwidth )) && key_longestwidth=${#1}

	# Inserting key and value
	logs+=("$1" "$2")
}

# Calling gathers
for gather in $to_gather; do
	[ $(declare -F "get_${gather}") ] && get_${gather} || echo "Gather '$v' is not defined."
done

# Preparing spacings
init_spacing=$(util_makespaces $SPACE_FROM_START)
art_spacing=$( (( artp_n > 0 )) && util_makespaces $SPACE_FROM_ART && echo )
artend_spacing=$(util_makespaces $art_width)
key_spacing=$(util_makespaces $SPACE_FROM_KEY)
delimiter_spacing=$( (( ${#DELIMITER_CHAR} > 0 )) && util_makespaces $SPACE_FROM_DELIMITER)

# Outputing $logs
log_i=0; artp_i=0
while ! (( ( log_i >= ${#logs[@]} ) && ( artp_i >= artp_n ) )); do
	# Initial spacing
	echo -ne "$init_spacing"

	# Art piece
	if (( artp_n > artp_i )); then
		artp=${ART[artp_i]}; (( artp_i++ ))

		# Getting rid of the ANSI Color to get width and correct it
		clr=$(util_rm_ansicolor "$artp")
		width_spacing=$(util_makespaces $(( art_width - ${#clr} )) )

		echo -ne "$artp$width_spacing$art_spacing"
	else
		(( artp_n > 0 )) && echo -ne "$artend_spacing$art_spacing"
	fi

	# Key & value
	if (( ${#logs[@]} > log_i )); then
		k=${logs[log_i]}; v=${logs[log_i+1]}; (( log_i+=2 ))

		# Spaces to lineup values
		lineup_spacing=$(util_makespaces $(( key_longestwidth - ${#k} )))

		(( ${#k} > 0 )) &&
		echo -ne "\e[${COLOR_KEY}m${k}$lineup_spacing${key_spacing}\e[${COLOR_DELIMITER}m$DELIMITER_CHAR$delimiter_spacing\e[${COLOR_VALUE}m$v" ||
		echo -ne "\e[${COLOR_VALUE}m$v"
	fi

	# New line & color reset
	echo -e "\e[0m"
done
